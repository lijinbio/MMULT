#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <boost/algorithm/string.hpp>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <cstdlib>
#include <thread>

#ifdef __APPLE__
#include <boost/dll/runtime_symbol_info.hpp>
#endif

#include "types.h"

using namespace boost::program_options;
using namespace std;

class Opts {
	public:
		vector< string > compfiles;
		vector< string > chromstr;
		vector< string > chroms;
		map< string, int > chromsizes;
		int length;
		int numbins;
		int numthreads;
		string outfile;
		Hist reference;
		string rscript;
		double kldthr;
		double cdifthr;
		int maxdistdmcs;
		int mindmc;
		double maxzerocdif;
	public:
		Opts(): numbins(100), numthreads(10), length(20000000), kldthr(0.67957), cdifthr(0.2), maxdistdmcs(300), mindmc(3), maxzerocdif(0.05) {}
	public:
		void out() {
			cout << "Comparison files: " << strjoin(compfiles) << endl;
			cout << "Number of comparison files: " << compfiles.size() << endl;
			cout << "Chromosomes: " << strjoin(chromstr) << endl;
			cout << "Number of bins: " << numbins << endl;
			cout << "Number of threads: " << numthreads << endl;
			cout << "KL-divergence threshold for a DMC: " << kldthr << endl;
			cout << "CDIF threshold for a DMC: " << cdifthr << endl;
			cout << "Max precent of zero CDIFs for a DMC: " << maxzerocdif << endl;
			cout << "Max distance between DMCs for a DMR: " << maxdistdmcs << endl;
			cout << "Min number of DMCs in a DMR: " << mindmc << endl;
			cout << "outfile: " << outfile << endl;
		}
} opts;

int parse_options(int ac, const char ** av) {
	try
	{
		options_description desc{"Allowed options"};
		desc.add_options()
			("help,h", "Produce help message.")
			("compfile,c", value< vector< string > >()->multitoken(), "Comparison files. The comparison file is generated by `MCOMP` in MOABS. For example, `-c H001VsNL -c H002VsNL`.")
			("chrom,r", value< vector< string > >()->multitoken(), "A specific chromosome for analysis. Can be specified multiple times for multiple chromosomes. The size can be encoded for a chromosome. For example, `-c chr1:248956422 -c chr2:242193529`. The size can be used to split a chromosome for running in small batches. Default: all chromosomes appear in comparison files.")
			("length,l", value<int>()->default_value(20000000), "Split length of coordinates in a chromomsome. This is necessary for many replicates with a limited memory. To enable small-batch running, size info should be specificed by `-r|--chrom`. Because the size of chr1 in hg38 is >200 million, 1/10th (20M) can be good to go. Default: 20000000.")
			("numbins,b", value<int>()->default_value(100), "Number of bins. Default: 100.")
			("numthreads,t", value<int>()->default_value(10), "Number of threads. Default: 10.")
			("kldthr", value<double>()->default_value(0.67957, "0.67957"), "KL-divergence threshold for a DMC. A quarter of nats. Default: 0.67957.")
			("cdifthr", value<double>()->default_value(0.2, "0.2"), "CDIF threshold for a DMC. Default: 0.2.")
			("maxzerocdif", value<double>()->default_value(0.05, "0.05"), "Maximum percent of zero CDIFs for a DMC. A CpG with both positive and negative CDIFs will be ignored. A negative value will not check zero CDIFs. Default: 5%.")
			("maxdistdmcs", value<int>()->default_value(300), "Maximum distance between consecutive DMCs for a DMR. Default: 300.")
			("mindmc", value<int>()->default_value(3), "Minimum number ofDMCs in a DMR. Default: 3.")
			("outfile,o", value<string>()->default_value(""), "Output file.")
			;

		variables_map vm;
		store(parse_command_line(ac, av, desc), vm);
		notify(vm);

		if (vm.count("help")) {
			cout << desc << endl;
			cout << "Examples: " <<endl;
			cout << "  " << av[0] << " -c H001VsNL -c H002VsNL -o output.txt" << endl;
			cout << endl;
			cout << "Date: 2020/08/19" << endl;
			cout << "Authors: Jin Li <lijin.abc@gmail.com>" << endl;
			exit(1);
		}

		for(map<string, variable_value>::iterator it=vm.begin(); it!=vm.end(); ++it) {
			string k=it->first;
			if( k == "compfile"){
				opts.compfiles=vm[k].as< vector< string > >();
			} else if( k == "chrom"){
				vector< string > vchrs=vm[k].as< vector< string > >();
				set< string > uniqchrs;
				for (string& chr: vchrs) {
					uniqchrs.insert(chr);
				}
				opts.chromstr.assign(uniqchrs.begin(), uniqchrs.end());

				for (string& chr: opts.chromstr) {
					vector< string > fields;
					boost::split(fields, chr, boost::is_any_of(":"));
					opts.chroms.push_back(fields[0]);
					if (fields.size()==2) {
						opts.chromsizes[fields[0]]=stoi(fields[1]);
					}
				}
			} else if( k == "length"){
				opts.length=vm[k].as<int>();
			} else if( k == "numbins"){
				opts.numbins=vm[k].as<int>();
			} else if( k == "numthreads"){
				opts.numthreads=vm[k].as<int>();
			} else if( k == "kldthr"){
				opts.kldthr=vm[k].as<double>();
			} else if( k == "cdifthr"){
				opts.cdifthr=vm[k].as<double>();
			} else if( k == "maxzerocdif"){
				opts.maxzerocdif=vm[k].as<double>();
			} else if( k == "maxdistdmcs"){
				opts.maxdistdmcs=vm[k].as<int>();
			} else if( k == "mindmc"){
				opts.mindmc=vm[k].as<int>();
			} else if( k == "outfile"){
				opts.outfile=vm[k].as<string>();
			} else {
				cerr << "Error: invalid option " << k << endl;
				exit(1);
			}
		}
#ifdef __APPLE__
		opts.rscript=boost::filesystem::canonical(boost::dll::program_location()).parent_path().string()+"/cpgcdifenrichhist.R";
#else
		opts.rscript=boost::filesystem::canonical("/proc/self/exe").parent_path().string()+"/cpgcdifenrichhist.R";
#endif
		if (opts.compfiles.empty()) {
			cerr << "Error: -c|--compfile must be specified." << endl;
			cout << desc << endl;
			exit(1);
		}
		if (opts.outfile.empty()) {
			cerr << "Error: -o|--outfile must be specified." << endl;
			cout << desc << endl;
			exit(1);
		}
		if (opts.chroms.empty()) {
			getchrs(opts.compfiles, opts.chroms);
			opts.chromstr.assign(opts.chroms.begin(), opts.chroms.end());
		}
		opts.out();
	} catch (const error &ex) {
		cerr << ex.what() << endl;
	}
	return 0;
}

// Left-close cut
int value2index(double lower, double upper, int K, double value) {
	double dindex=(value-lower)*K/(upper-lower); // [a, b)
	// To fix the double precision problem
	// Round to the boundary
	if (fabs(round(dindex)-dindex)<1e-9) {
		dindex=round(dindex);
	}
	int index=(int)dindex;
	if (index<0) index=0;
	if (index>=K) index=K-1;
	return index;
}

int compfile2counts(string& compfile, double lower, double upper, int numbins, vector< long long >& counts)
{
	counts.resize(numbins, 0);
	int colIdForCDIF=13;
	ifstream fin(compfile);
	string line;
	while ((fin.good() && !fin.eof()) && getline(fin, line)) {
		if (line.empty() || line[0]=='#') continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of("\t"));
		if (fields[colIdForCDIF]!="NA") {
			// a potential bug here: -0.9 -> -0.90000000000000002220446, int(cdif) become buggy for index.
			// No matter of stof(), stold(), or stringstream
			double cdif=stold(fields[colIdForCDIF]);
			int binindex=value2index(lower, upper, numbins, cdif);
			counts[binindex]++;
		}
	}
	fin.close();
	return 0;
}

int compfiles2referencehist(
	vector< string >& compfiles
	, Hist& reference
	, int numbins
	, double lower
	, double upper
	, int numthreads
	)
{
	cout << "start generating the reference distribution" << endl;
	vector< vector< long long > > compcounts(compfiles.size());
	std::thread thds[numthreads];
	int compindex=0;
	while (compindex<compfiles.size()) {
		for (int i=0; i<numthreads && compindex<compfiles.size(); ++i, ++compindex) {
			thds[i]=std::thread(compfile2counts
					, std::ref(compfiles[compindex])
					, lower
					, upper
					, numbins
					, std::ref(compcounts[compindex])
					);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
	}
	reference.counts.resize(numbins, 0);
	for (auto comp: compcounts) {
		for (int i=0; i<numbins; ++i) {
			reference.counts[i]+=comp[i];
		}
	}
	reference.lower=lower;
	reference.upper=upper;
	reference.numbins=numbins;
	reference.counts2hist();
	cout << "finish generating the reference distribution" << endl;
	return 0;
}

int compfile2cmeth(string& compfile, string& chr, map< int, double >& cdif)
{
	if (!boost::filesystem::exists(compfile)) {
		cerr << "Error: input file missing " << compfile << endl;
		exit(1);
	}
	cout << "start reading file " << compfile << " " << chr << endl;
	readCDIF(compfile, cdif, chr);
	cout << "finish reading file " << compfile << " " << chr << endl;
	return 0;
}

// [lower, upper)
int compfile2cmethrange(string& compfile, string& chr, int lower, int upper, map< int, double > & cdif)
{
	if (!boost::filesystem::exists(compfile)) {
		cerr << "Error: input file missing " << compfile << endl;
		exit(1);
	}
	cout << "start reading file " << compfile << " " << chr << " [" << lower << "," << upper << ")" << endl;
	readCDIF(compfile, cdif, chr, lower, upper);
	cout << "finish reading file " << compfile << " " << chr << " [" << lower << "," << upper << ")" << endl;
	return 0;
}

int files2cmethg(
		vector< string >& compfiles
		, string& chr
		, vector< map< int, double > >& repcdif
		, int numthreads
		)
{
	repcdif.resize(compfiles.size());
	std::thread thds[numthreads];
	int compindex=0;
	while (compindex<compfiles.size()) {
		for (int i=0; i<numthreads && compindex<compfiles.size(); ++i, ++compindex) {
			thds[i]=std::thread(compfile2cmeth
					, std::ref(compfiles[compindex])
					, std::ref(chr)
					, std::ref(repcdif[compindex])
					);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
	}
	return 0;
}

int files2cmethg(
		vector< string >& compfiles
		, string& chr
		, int lower
		, int upper
		, vector< map< int, double > >& repcdif
		, int numthreads
		)
{
	repcdif.resize(compfiles.size());
	std::thread thds[numthreads];
	int compindex=0;
	while (compindex<compfiles.size()) {
		for (int i=0; i<numthreads && compindex<compfiles.size(); ++i, ++compindex) {
			thds[i]=std::thread(compfile2cmethrange
					, std::ref(compfiles[compindex])
					, std::ref(chr)
					, lower
					, upper
					, std::ref(repcdif[compindex])
					);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
	}
	return 0;
}

int rep2cpgcdif(vector< map< int, double > >& repcdif, int start, vector< double >& cpgcdifs)
{
	for (auto& rep: repcdif) {
		if (rep.end()!=rep.find(start)) {
			cpgcdifs.push_back(rep[start]);
		}
	}
	return 0;
}

int repcdif2cdifs(vector< map< int, double > >& repcdif, map< int, vector< double > >& cdifs, int numthreads)
{
	set< int > starts;
	for (auto& rep: repcdif) {
		for (auto& cpg: rep) {
			starts.insert(cpg.first);
		}
	}
	set< int >::iterator pstart=starts.begin();
	while (pstart!=starts.end()) {
		vector< vector< double > > result(numthreads);
		vector< int > rstarts;
		std::thread thds[numthreads];
		for (int i=0; i<numthreads && pstart!=starts.end(); ++i, ++pstart) {
			int start=(*pstart);
			thds[i]=std::thread(rep2cpgcdif
					, std::ref(repcdif)
					, start
					, std::ref(result[i])
					);
			rstarts.push_back(start);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
		for (int i=0; i<numthreads; i++) {
			if (!result[i].empty()) {
				cdifs[rstarts[i]]=result[i];
			}
		}
	}
	/*
	for (auto it=starts.begin(); starts.end()!=it; ++it) {
		int start=(*it);
		vector< double > cpgcdifs;
		for (auto& rep: repcdif) {
			if (rep.end()!=rep.find(start)) {
				cpgcdifs.push_back(rep[start]);
			}
		}
		if (!cpgcdifs.empty()) {
			cdifs[start]=cpgcdifs;
		}
	}
	*/
	return 0;
}

int compfiles2cmeth(
		vector< string >& compfiles
		, string& chr
		, int lower
		, int upper
		, map< int, vector< double > >& cdifs
		, int numthreads
		)
{
	vector< map< int, double > > repcdif;
	files2cmethg(compfiles, chr, lower, upper, repcdif, numthreads);
	repcdif2cdifs(repcdif, cdifs, numthreads);
	repcdif.clear();
	return 0;
}

int compfiles2cmeth(
		vector< string >& compfiles
		, string& chr
		, map< int, vector< double > >& cdifs
		, int numthreads
		)
{
	vector< map< int, double > > repcdif;
	files2cmethg(compfiles, chr, repcdif, numthreads);
	repcdif2cdifs(repcdif, cdifs, numthreads);
	repcdif.clear();
	return 0;
}

double vec2mean(vector< double >& vec) {
	double sum=0.0;
	for (double v: vec) {
		sum+=v;
	}
	return sum/vec.size();
}

double vec2sum(vector< double >& vec) {
	double sum=0.0;
	for (double v: vec) {
		sum+=v;
	}
	return sum;
}

double vec2sdmean(vector< double >& vec) {
	double sum=0.0;
	int N=0;
	for (double v: vec) {
		if (v>-1) {
			sum+=v;
			N++;
		}
	}
	double sd=-1;
	if (N>0) {
		sd=sum/N;
	}
	return sd;
}

double vec2sd(vector< double >& vec) {
	if (vec.size()<2) return -1;
	double mean=vec2mean(vec);
	double ss=0.0;
	for (double v: vec) {
		ss+=(v-mean)*(v-mean);
	}
	return sqrt(ss/(vec.size()-1));
}

int vec2pi(vector< double >& vec, vector< double >& pi, double lower, double upper, int K)
{
	vector< int > counts(K, 0);
	for (double v: vec) {
		int index=value2index(lower, upper, K, v);
		counts[index]++;
	}
	int N=0;
	for (int c: counts) {
		N+=c;
	}
	if (N==0) return 1;
	for (int c: counts) {
		pi.push_back(1.0*c/N);
	}
	return 0;
}

double pi2kld(vector< double >& pi, vector< double >& refpi)
{
	double kld=0;
	for (int i=0; i<pi.size(); i++) {
		if (pi[i]>0) {
			kld+=pi[i]*log(pi[i]/refpi[i]);
		}
	}
	return kld;
}

double pi2we(vector< double >& pi, vector< double >& refpi)
{
	double we=0;
	for (int i=0; i<pi.size(); i++) {
		if (pi[i]>0) {
			we+=-pi[i]*log(pi[i])/refpi[i];
		}
	}
	return we;
}

double pi2entropy(vector< double >& pi)
{
	double e=0;
	for (int i=0; i<pi.size(); i++) {
		if (pi[i]>0) {
			e+=-pi[i]*log(pi[i]);
		}
	}
	return e;
}

void cdifenrichworker(
		string& chr
		, map< int, vector< double > >::iterator it
		, map< int, vector< double > >::iterator& pend
		, int pstart
		, string& output
		)
{
	advance(it, pstart);
	ostringstream sout;
	for (int i=0; i<BATCH && it!=pend; ++i, ++it) {
		int start=(it->first);
		vector< double >& c=it->second;
		double mean=vec2mean(c);
		double sum=vec2sum(c);
		double sd=vec2sd(c);
		vector< double > pi;
		vec2pi(c, pi, -1, 1, opts.numbins);
		double kld=pi2kld(pi, opts.reference.pi);
		double we=pi2we(pi, opts.reference.pi);
		double entropy=pi2entropy(pi);
		sout << chr << '\t'
			<< start << '\t'
			<< start+1 << '\t'
			<< c.size() << '\t'
			<< mean << '\t'
			<< sum << '\t'
			<< sd << '\t'
			<< kld << '\t'
			<< we << '\t'
			<< entropy << '\t'
			<< strjoin(c) << endl;
	}
	output=sout.str();
}

int cdifs2cdifenrich(
		map< int, vector< double > >& cdifs
		, string& chr
		, int numthreads
		, string& outfile
		)
{
	ofstream fout(outfile);
	map< int, vector< double > >::iterator pbegin=cdifs.begin();
	map< int, vector< double > >::iterator pend=cdifs.end();
	int pstart=0;
	while (pstart<cdifs.size()) {
		std::thread thds[numthreads];
		vector< string > result(numthreads);
		for (int i=0; i<numthreads && pstart<cdifs.size(); ++i) {
			thds[i]=std::thread(cdifenrichworker
					, std::ref(chr)
					, std::ref(pbegin)
					, std::ref(pend)
					, pstart
					, std::ref(result[i])
					);
			pstart+=BATCH;
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
		for (string& sout: result) {
			fout << sout;
		}
	}
	return 0;
}

int cdifenrichbychrsplit(vector< string >& compfiles, string& chr, int lower, int upper, string& outfile)
{
	cout << "Start processing " << chr << " [" << lower << "," << upper << ")" << endl;
	map< int, vector< double > > cdifs;
	compfiles2cmeth(compfiles, chr, lower, upper, cdifs, opts.numthreads);
	cdifs2cdifenrich(cdifs, chr, opts.numthreads, outfile);
	cout << "Finish " << chr << " [" << lower << "," << upper << ")" << endl;
	return 0;
}

int mergesplitfile(vector< string >& outfiles, string& outfile)
{
	string sysCmd;
	sysCmd = "cat " + strjoin(outfiles, " ") + " > " + outfile;
	system(sysCmd.c_str());
	sysCmd = "rm -f " + strjoin(outfiles, " ");
	system(sysCmd.c_str());
	return 0;
}

int cpgcdifenrichbychr(vector< string >& compfiles, string& chr, int chromsize, int length, string& outfile)
{
	cout << "Start processing " << chr << endl;
	vector< string > splitfiles;
	for (int lower=1; lower<=chromsize; lower+=length) {
		int upper=lower+length;
		string splitfile=outfile+"_"+tostring(lower)+"_"+tostring(upper)+".txt";
		cdifenrichbychrsplit(compfiles, chr, lower, upper, splitfile); // [lower, upper)
		splitfiles.push_back(splitfile);
	}
	mergesplitfile(splitfiles, outfile);
	cout << "Finish " << chr << endl;
	return 0;
}

int cpgcdifenrichbychr(vector< string >& compfiles, string& chr, string& outfile)
{
	cout << "Start processing " << chr << endl;
	map< int, vector< double > > cdifs;
	compfiles2cmeth(compfiles, chr, cdifs, opts.numthreads);
	cdifs2cdifenrich(cdifs, chr, opts.numthreads, outfile);
	cout << "Finish " << chr << endl;
	return 0;
}

int mergechroutfiles(vector< string >& outfiles, string& outfile) {
	ofstream mergedLaneFile;
	mergedLaneFile.open(outfile.c_str(), ios_base::out);
	mergedLaneFile << "#chrom\tstart\tend\tnumsample\tCDIFmean\tCDIFsum\tCDIFsd\tKLDivergence\tWeightedEntropy\tEntropy\tCDIFs" << endl;
	mergedLaneFile.close();

	string sysCmd;
	sysCmd = "cat " + strjoin(outfiles, " ") + " >> " + outfile;
	system(sysCmd.c_str());
	sysCmd = "rm -f " + strjoin(outfiles, " ");
	system(sysCmd.c_str());
	return 0;
}

int rplothist(string& infile, string& outfile) {
	string cmd = "R --slave --no-save --no-restore --no-init-file";
	cmd+=" -e width=9";
	cmd+=" -e height=9";
	cmd+=" -e \"infile='"+infile+"'\"";
	cmd+=" -e \"outfile='"+outfile+"'\"";
	cmd+=" -e \"source('" + opts.rscript + "')\"";
	cout << cmd << endl;
	FILE *fp;
	char info[10240];
	fp = popen(cmd.c_str(), "r");
	if (fp==NULL) {
		fprintf(stderr, "popen error.\n");
		return EXIT_FAILURE;
	}
	while (fgets(info, 10240, fp) != NULL) {
		fprintf(stderr, "%s", info);
	}
	pclose(fp);
	return 0;
}

int readreferencehist(string& infile, Hist& hist)
{
	cout << "start reading the reference distribution from " << infile << endl;
	hist.lower=-1;
	hist.upper=1;
	hist.numbins=opts.numbins;
	// label<TAB>counts<TAB>density<TAB>pi
	ifstream fin(infile);
	string line;
	while ((fin.good() && !fin.eof()) && getline(fin, line)) {
		if (line.empty() || line[0]=='#') continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of("\t"));
		string label=fields[0];
		if (label=="label") continue;
		long long count=stoll(fields[1]);
		hist.counts.push_back(count);
		// hist.labels.push_back(label);
		// double density=stold(fields[2]);
		// hist.density.push_back(density);
		// double pi=stold(fields[3]);
		//hist.pi.push_back(pi);
	}
	fin.close();
	hist.counts2hist();
	cout << "finish reading the reference distribution" << endl;
	hist.output(cout);

	if (hist.numbins!=hist.pi.size()) {
		cerr << "Error: numbins does not match input probabilities " << infile << endl;
		exit(1);
	}
	return 0;
}

// Criteria to skip a CpG for DMC:
// 1. Both positive or negative exist in CDIFs, or
// 2. maxzerocdif is greater equal to 0, and the percent of zero CDIFs is greater than maxzerocdif
bool skipbycdifs(string strcdifs, double maxzerocdif)
{
	vector< string > cdiffields;
	boost::split(cdiffields, strcdifs, boost::is_any_of(","));
	int numzero=0;
	int numgreaterzero=0;
	int numlesszero=0;
	for (int i=0; i<cdiffields.size(); i++) {
		double cdif=stold(cdiffields[i]);
		if (fabs(cdif)<1e-6) {
			numzero++;
		} else if (cdif>0) {
			numgreaterzero++;
		} else {
			numlesszero++;
		}
	}
	if ((numgreaterzero>0) && (numlesszero>0)) {
		return true;
	}
	if (!(maxzerocdif<0) && (1.0*numzero/(numzero+numgreaterzero+numlesszero)) > maxzerocdif) {
		return true;
	}
	return false;
}

int cpgcdifenrich2dmcdmr(string& infile, string& dmcfile, string& dmrfile, double kldthr, double cdifthr, double maxzerocdif, int maxdistdmcs, int mindmc)
{
	map< string, map< int, DMC > > dmcs; // chr->start->DMC
	ofstream dmcout(dmcfile);
	dmcout << "#chrom\tstart\tend\tnumsample\tmeanCDIF\tsumCDIF\tKLDivergence\tsd\tentropy\tclass" << endl;
	ifstream fin(infile);
	string line;
	while ((fin.good() && !fin.eof()) && getline(fin, line)) {
		if (line.empty() || line[0]=='#') continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of("\t"));

		double kld=stold(fields[7]);
		if (kld<kldthr) continue; // not significant
		double sumcdif=stold(fields[5]); // sum of CDIF
		if (fabs(sumcdif)<cdifthr) continue; // not significant

		string strcdifs=fields[10];
		if (!(maxzerocdif<0) && skipbycdifs(strcdifs, maxzerocdif)) continue;

		DMC dmc;
		dmc.chrom=fields[0];
		dmc.start=stoi(fields[1]);
		dmc.end=stoi(fields[2]);
		dmc.sd=stold(fields[6]);
		dmc.kld=kld;
		dmc.meancdif=stold(fields[4]);
		dmc.sumcdif=sumcdif;
		dmc.entropy=stold(fields[9]);
		dmc.label=(sumcdif<0) ? "hypo" : "hyper";

		dmcs[dmc.chrom][dmc.start]=dmc;

		int numsample=stoi(fields[3]);
		dmcout << dmc.chrom << '\t'
			<< dmc.start << '\t'
			<< dmc.end << '\t'
			<< numsample << '\t'
			<< dmc.meancdif << '\t'
			<< dmc.sumcdif << '\t'
			<< dmc.kld << '\t'
			<< dmc.sd << '\t'
			<< dmc.entropy << '\t'
			<< dmc.label << endl;
	}
	fin.close();
	dmcout.close();

	ofstream dmrout(dmrfile);
	dmrout << "#chrom\tstart\tend\t#dmc\tmeancdif\tkld\tsd\tclass" << endl;
	for (auto chrit=dmcs.begin(); chrit!=dmcs.end(); ++chrit) {
		map< int, DMC >& dmcchr=chrit->second;
		DMR dmr;
		for (auto dmcit=dmcchr.begin(); dmcchr.end()!=dmcit; ++dmcit) {
			DMC& dmc=dmcit->second;
			if (dmr.start==-1) { // the first DMC
				dmr.chrom=dmc.chrom;
				dmr.start=dmc.start;
				dmr.end=dmc.end;
				dmr.meancdif.push_back(dmc.meancdif);
				dmr.kld.push_back(dmc.kld);
				dmr.sd.push_back(dmc.sd);
				dmr.label=dmc.label;
			} else { // trying to extend a DMR
				if (dmc.label!=dmr.label || dmc.start-dmr.end>maxdistdmcs) { // can not extend
					if (dmr.meancdif.size()>=mindmc) { // save a DMR
						double meancdif=vec2mean(dmr.meancdif);
						double meankld=vec2mean(dmr.kld);
						double meansd=vec2sdmean(dmr.sd);
						dmrout << dmr.chrom << '\t'
							<< dmr.start << '\t'
							<< dmr.end << '\t'
							<< dmr.meancdif.size() << '\t'
							<< meancdif << '\t'
							<< meankld << '\t'
							<< meansd << '\t'
							<< dmr.label << endl;
					}
					dmr.clear();
					dmr.chrom=dmc.chrom; // start a new DMR from this DMC
					dmr.start=dmc.start;
					dmr.end=dmc.end;
					dmr.meancdif.push_back(dmc.meancdif);
					dmr.kld.push_back(dmc.kld);
					dmr.sd.push_back(dmc.sd);
					dmr.label=dmc.label;
				} else { // extending a DMR
					dmr.end=dmc.end;
					dmr.meancdif.push_back(dmc.meancdif);
					dmr.kld.push_back(dmc.kld);
					dmr.sd.push_back(dmc.sd);
				}
			}
		}
		if (dmr.meancdif.size()>=mindmc) { // try to save the last DMR
			double meancdif=vec2mean(dmr.meancdif);
			double meankld=vec2mean(dmr.kld);
			double meansd=vec2sdmean(dmr.sd);
			dmrout << dmr.chrom << '\t'
				<< dmr.start << '\t'
				<< dmr.end << '\t'
				<< dmr.meancdif.size() << '\t'
				<< meancdif << '\t'
				<< meankld << '\t'
				<< meansd << '\t'
				<< dmr.label << endl;
		}
	}
	dmrout.close();
	return 0;
}

int main(int argc, const char ** argv)
{
	parse_options(argc, argv);
	boost::filesystem::create_directories(boost::filesystem::absolute(opts.outfile).parent_path());
	string obname=boost::filesystem::path(opts.outfile).replace_extension().string();

	if (!boost::filesystem::exists(opts.outfile)) {
		string refhistfile=obname+"_hist.txt";
		if (!boost::filesystem::exists(refhistfile)) {
			compfiles2referencehist(opts.compfiles, opts.reference, opts.numbins, -1, 1, opts.numthreads);
			opts.reference.output(refhistfile);
		} else {
			readreferencehist(refhistfile, opts.reference);
		}
		string refhistplot=obname+"_hist.pdf";
		rplothist(refhistfile, refhistplot);

		vector< string > chroutfiles;
		for (string& chr : opts.chroms) {
			string chroutfile=opts.outfile+"_"+chr+".txt";
			if (!boost::filesystem::exists(chroutfile)) {
				if (opts.chromsizes.end()!=opts.chromsizes.find(chr)) {
					cpgcdifenrichbychr(opts.compfiles, chr, opts.chromsizes[chr], opts.length, chroutfile);
				} else {
					cpgcdifenrichbychr(opts.compfiles, chr, chroutfile);
				}
			}
			chroutfiles.push_back(chroutfile);
		}
		mergechroutfiles(chroutfiles, opts.outfile);
	}

	string dmcfile=obname+".dmc.txt";
	string dmrfile=obname+".dmr.txt";
	cpgcdifenrich2dmcdmr(opts.outfile, dmcfile, dmrfile, opts.kldthr, opts.cdifthr, opts.maxzerocdif, opts.maxdistdmcs, opts.mindmc);
	return 0;
}
