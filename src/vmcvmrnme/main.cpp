#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <boost/algorithm/string.hpp>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <cstdlib>
#include <thread>
#include <algorithm>
#include <cmath>

#include "types.h"

using namespace boost::program_options;
using namespace std;

class Opts {
	public:
		vector< vector< string > > methfiles;
		vector< string > chroms;
		int Jx;
		int Kx;
		int K;
		int window;
		int mincpg;
		int mindepth;
		int numthreads;
		string outfile;
		string vmcfile;
		string windowfile;
		int vmrmethod;
		double sd;
		double NME;
		int maxdistvmcs;
		int minsample;
	public:
		Opts(): Jx(0), Kx(0), K(2), window(150), mincpg(3), mindepth(3), numthreads(8), vmrmethod(0), sd(0.2), NME(0.25), maxdistvmcs(300), minsample(5) {}
	public:
		void out() {
			cout << "Methylation files:" << endl;
			for (int i=0; i<methfiles.size(); i++) {
				cout << "group" << i+1 << ": " << strjoin(methfiles[i]) << endl;
			}
			cout << "Chromosomes: " << strjoin(chroms) << endl;
			cout << "Number of samples: " << Jx << endl;
			cout << "Number of groups: " << Kx << endl;
			cout << "Number of discretization states: " << K << endl;
			cout << "Window size: " << window << endl;
			cout << "Minimum CpG: " << mincpg << endl;
			cout << "Minimum depth: " << mindepth << endl;
			cout << "numthreads: " << numthreads << endl;
			cout << "outfile: " << outfile << endl;
			cout << "vmcfile: " << vmcfile << endl;
			cout << "windowfile: " << windowfile << endl;
			cout << "VMR method: " << vmrmethod << endl;
			cout << "sd for VMC: " << sd << endl;
			cout << "NME for VMC: " << NME << endl;
			cout << "Max distance between VMCs: " << maxdistvmcs << endl;
			cout << "Min sample for a CpG: " << minsample << endl;
		}
} opts;

int parse_options(int ac, const char ** av) {
	try
	{
		options_description desc{"Allowed options"};
		desc.add_options()
			("help,h", "Produce help message.")
			("methfile,m", value< vector< string > >()->multitoken(), "Methylation BED files. The BED file is generated by `MCALL` in MOABS. Replicates are concatenated by comma `,`. For example, `-m r1.bed,r2.bed,r3.bed`.")
			("chrom,c", value< vector< string > >()->multitoken(), "One specific-chromosome for analysis. Can be specified multiple times for multiple chromosomes. Default: all chromosomes appear in methylation BED files.")
			("outfile,o", value<string>()->default_value(""), "Output file.")
			("state,k", value<int>()->default_value(2), "Number of discretization states. Default: 2.")
			("window,w", value<int>()->default_value(150), "Window size for genome scan. Default: 150.")
			("mincpg,b", value<int>()->default_value(3), "Minimum CpGs in a window. Default: 3.")
			("mindepth,d", value<int>()->default_value(3), "Minimum depth for a CpG coverage. Default: 3.")
			("numthreads,t", value<int>()->default_value(8), "Number of threads. Default: 8.")
			("vmrmethod,v", value<int>()->default_value(0), "VMR detection method. 0: identify VMCs first and detect VMRs from consecutive VMCs; 1: Genome scan method by fixed-size windows. Default: 0.")
			("sd,s", value<double>()->default_value(0.2, "0.2"), "sd for VMC. Default: 0.2.")
			("nme,n", value<double>()->default_value(0.25), "NME for VMC. Default: 0.25.")
			("maxdistvmcs,x", value<int>()->default_value(300), "Maximum distance between consecutive VMCs for VMR. Default: 300.")
			("minsample", value<int>()->default_value(5), "Minimum samples for a CpG. Default: 5.")
			("vmcfile", value<string>()->default_value(""), "VMC file.")
			("windowfile", value<string>()->default_value(""), "VMR file by genome scan.")
			;

		variables_map vm;
		store(parse_command_line(ac, av, desc), vm);
		notify(vm);

		if (vm.count("help")) {
			cout << desc << endl;
			cout << "Examples: " <<endl;
			cout << "  " << av[0] << " -m r1.bed,r2.bed,r3.bed -o output.txt" << endl;
			cout << endl;
			cout << "Date: 2020/05/20" << endl;
			cout << "Authors: Jin Li <lijin.abc@gmail.com>" << endl;
			exit(0);
		}

		for(map<string, variable_value>::iterator it=vm.begin(); it!=vm.end(); ++it) {
			string k=it->first;
			if( k == "methfile"){
				vector< string > files=vm[k].as< vector< string > >();
				int numsample=0;
				int numgroup=0;
				for (string &fstr: files) {
					vector< string > gfiles;
					boost::split(gfiles, fstr, boost::is_any_of(","));
					opts.methfiles.push_back(gfiles);
					numsample+=gfiles.size();
					numgroup++;
				}
				opts.Jx=numsample;
				opts.Kx=numgroup;
			} else if( k == "chrom"){
				vector< string > vchrs=vm[k].as< vector< string > >();
				set< string > uniqchrs;
				for (string& chr: vchrs) {
					uniqchrs.insert(chr);
				}
				opts.chroms.assign(uniqchrs.begin(), uniqchrs.end());
			} else if( k == "outfile"){
				opts.outfile=vm[k].as<string>();
			} else if( k == "vmcfile"){
				opts.vmcfile=vm[k].as<string>();
			} else if( k == "windowfile"){
				opts.windowfile=vm[k].as<string>();
			} else if( k == "numthreads"){
				opts.numthreads=vm[k].as<int>();
			} else if( k == "state"){
				opts.K=vm[k].as<int>();
			} else if( k == "window"){
				opts.window=vm[k].as<int>();
			} else if( k == "mincpg"){
				opts.mincpg=vm[k].as<int>();
			} else if( k == "mindepth"){
				opts.mindepth=vm[k].as<int>();
			} else if( k == "vmrmethod"){
				opts.vmrmethod=vm[k].as<int>();
			} else if( k == "sd"){
				opts.sd=vm[k].as<double>();
			} else if( k == "nme"){
				opts.NME=vm[k].as<double>();
			} else if( k == "maxdistvmcs"){
				opts.maxdistvmcs=vm[k].as<int>();
			} else if( k == "minsample"){
				opts.minsample=vm[k].as<int>();
			} else {
				cerr << "Error: invalid option " << k << endl;
				exit(1);
			}
		}
		if (opts.methfiles.empty()) {
			cerr << "Error: -m|--methfile must be specified." << endl;
			cout << desc << endl;
			exit(1);
		}
		if (opts.outfile.empty()) {
			cerr << "Error: -o|--outfile must be specified." << endl;
			cout << desc << endl;
			exit(1);
		}
		if (opts.chroms.empty()) {
			getchrs(opts.methfiles, opts.chroms);
		}
		opts.out();
	} catch (const error &ex) {
		cerr << ex.what() << endl;
	}
	return 0;
}

int methfile2cmeth(string& methfile, string& chr, map< int, double >& methratios)
{
	cout << "start reading file " << methfile << " " << chr << endl;
	readLaneToStrandSpecificHash(methfile, methratios, chr, opts.mindepth);
	cout << "finish reading file " << methfile << " " << chr << endl;
	return 0;
}

int methfiles2cmeth(vector< string >& methfiles, string& chr, vector< map< int, double > >& cmeths)
{
	for (string& methfile: methfiles) {
		map< int, double > cmeth;
		methfile2cmeth(methfile, chr, cmeth);
		cmeths.push_back(cmeth);
	}
	return 0;
}

int methfiles2cmeththread(vector< string >& methfiles, string& chr, vector< map< int, double > >& cmeths, int numthreads)
{
	cmeths.resize(methfiles.size());
	std::thread thds[numthreads];
	int methindex=0;
	while (methindex<methfiles.size()) {
		for (int i=0; i<numthreads && methindex<methfiles.size(); ++i, ++methindex) {
			thds[i]=std::thread(methfile2cmeth
					, std::ref(methfiles[methindex])
					, std::ref(chr)
					, std::ref(cmeths[methindex])
					);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
	}
	return 0;
}

double vec2mean(vector< double >& vec) {
	double sum=0.0;
	for (double v: vec) {
		sum+=v;
	}
	return sum/vec.size();
}

double vec2sd(vector< double >& vec) {
	if (vec.size()<2) return -1;
	double mean=vec2mean(vec);
	double ss=0.0;
	for (double v: vec) {
		ss+=(v-mean)*(v-mean);
	}
	return sqrt(ss/(vec.size()-1));
}

int averagecpgmeansd(vector< vector< double > >& ratios, double& nominal, double& sd) {
	nominal=-1;
	sd=-1;
	if (ratios.empty() || ratios[0].empty()) return 0;
	vector< double > cpgsds;
	vector< double > cpgnominals;
	for (int c=0; c<ratios[0].size(); ++c) {
		vector< double > repratio;
		for (int r=0; r<ratios.size(); ++r) {
			if (ratios[r][c]>-1) {
				repratio.push_back(ratios[r][c]);
			}
		}
		if (repratio.size()>1) {
			cpgsds.push_back(vec2sd(repratio));
			cpgnominals.push_back(vec2mean(repratio));
		}
	}
	if (!cpgnominals.empty()) {
		nominal=vec2mean(cpgnominals);
	}
	if (!cpgsds.empty()) {
		sd=vec2mean(cpgsds);
	}
	return 0;
}

int naomit(vector< vector< double > >& srcratio, vector< vector< double > >& destratio) {
	for (auto& row: srcratio) {
		bool nafound=false;
		for (double ratio: row) {
			if (ratio<0) {
				nafound=true;
				break;
			}
		}
		if (!nafound) {
			destratio.push_back(row);
		}
	}
	return 0;
}

char discretize(double lower, double upper, int K, double value) {
	int index=(value-lower)*K/(upper-lower);
	if (index<0) index=0;
	if (index>=K) index=K-1;
	return discretizelabel[index];
}

double ratios2NME(vector< vector< double > >& ratios) {
	if (ratios.empty() || ratios[0].empty()) return -1;
	int N=ratios.size();
	int b=ratios[0].size();
	map< string, int > freqs;
	for (auto& replicate: ratios) {
		string pattern;
		for (double r: replicate) {
			pattern+=discretize(0, 1, opts.K, r);
		}
		freqs[pattern]++;

		/*
		// debug
		cout << pattern << "\t" << strjoin(replicate) << endl;
		*/
	}
	vector< double > probs;
	for (auto& freq: freqs) {
		probs.push_back(freq.second*1.0/N);
	}
	double nme=0;
	for (double p: probs) {
		if (p>0) {
			nme+=(-1.0)*p*log2(p);
		}
	}
	nme*=1.0/(b*log2(1.0*opts.K));

	/*
	// debug
	vector< int > infofreq;
	for (auto& freq: freqs) {
	cout << freq.first << "\t" << freq.second << "\t" << endl;
	infofreq.push_back(freq.second);
	}
	cout << "NME: "
	<< nme << "; N: "
	<< N << "; b: "
	<< b << "; prob: "
	<< probs.size() << "; "
	<< strjoin(probs) << "; "
	<< strjoin(infofreq) << endl;
	*/
	return nme;
}

int regionNME(vector< vector< double > >& ratios, double& NME) {
	vector< vector< double > > nonaratios;
	naomit(ratios, nonaratios);
	if (nonaratios.empty()) {
		NME=-1;
	} else {
		NME=ratios2NME(nonaratios);
	}
	return 0;
}

int vmrregion(Region& region) {
	averagecpgmeansd(region.ratios, region.nominal, region.sd);
	regionNME(region.ratios, region.NME);
	return 0;
}

void vmrworker(vector< Region >& regions, string& chr, int rstart, string& output) {
	ostringstream sout;
	for (int r=0; r<BATCH && rstart<regions.size(); ++r, ++rstart) {
		Region& region=regions[rstart];
		vmrregion(region);
		sout << chr << '\t'
			<< region.start << '\t'
			<< region.end << '\t'
			<< region.N << '\t'
			<< region.b << '\t'
			<< strjoin(region.cpgs) << '\t'
			<< region.nominal << '\t'
			<< region.sd << '\t'
			<< region.NME << '\t'
			<< (((region.sd<0) || !(region.NME>0))?-1:(region.sd*region.b/region.NME))
			<< endl;
	}
	output=sout.str();
}

int regionmap2vector(vector< map< int, double > >& regionmap, Region& region) {
	region.N=regionmap.size();
	set< int > uniqcpgs;
	for (auto& replicate: regionmap) {
		for (auto& cpg: replicate) {
			uniqcpgs.insert(cpg.first);
		}
	}
	region.b=uniqcpgs.size();
	if (region.b<opts.mincpg || region.b==0) return 1;
	region.start=(*uniqcpgs.begin());
	region.end=(*uniqcpgs.rbegin());
	region.cpgs.assign(uniqcpgs.begin(), uniqcpgs.end());

	map<int, int> coord2index;
	for (int i=0; i<region.cpgs.size(); i++) {
		coord2index[region.cpgs[i]]=i;
	}
	region.ratios.resize(region.N, vector< double > (region.b, -1)); // -1: missing data
	for (int r=0; r<region.N; r++) {
		for (auto& cpg: regionmap[r]) {
			region.ratios[r][coord2index[cpg.first]]=cpg.second;
		}
	}
	return 0;
}

int cut(
		int chrstart
		, int chrend
		, int window
		, vector< map< int, double > >& cmeths
		, vector< Region >& regions
		)
{
	cout << "Genome scan: " << chrstart << " " << chrend << " by window " << window << endl;
	int numwindow=1+(chrend-chrstart+1)/window;
	int N=cmeths.size();
	vector< vector< map< int, double > > > cratioregionmap(
			numwindow
			, vector< map< int, double > > (N)
			);
	cout << "Num of window: " << numwindow << " N: " << N << endl;
	for (int r=0; r<N; r++) {
		for (auto& cpg: cmeths[r]) {
			// cout << (cpg.first-chrstart)/window << " " << r << " " << cpg.first << " " << cpg.second << endl;
			cratioregionmap[(cpg.first-chrstart)/window][r][cpg.first]=cpg.second;
		}
	}

	for (int i=0; i<numwindow; i++) {
		Region region;
		if (0==regionmap2vector(cratioregionmap[i], region)) {
			regions.push_back(region);
		}
	}

	/*
	// debug
	for (int i=0; i<regions.size(); i++) {
	regions[i].out();
	}
	*/

	return 0;
}

int cmeths2regions(vector< map< int, double > >& cmeths, vector< Region >& regions) {
	int chrstart=INT_MAX;
	int chrend=-1;
	for (auto& replicate: cmeths) {
		chrstart=min(chrstart, int(replicate.begin()->first));
		chrend=max(chrend, int(replicate.rbegin()->first));
	}
	cut(chrstart, chrend, opts.window, cmeths, regions);
	return 0;
}

int methfiles2regions(vector< string >& methfiles, string& chr, vector< Region >& regions)
{
	vector< map< int, double > > cmeths; // replicate->pos->ratio
	// methfiles2cmeth(methfiles, chr, cmeths);
	methfiles2cmeththread(methfiles, chr, cmeths, opts.numthreads);
	cmeths2regions(cmeths, regions);
	return 0;
}

int vmrbychr(vector< string >& methfiles, string& chr, string& outfile) {
	cout << "Start processing " << chr << endl;
	vector< Region > regions;
	methfiles2regions(methfiles, chr, regions);

	ofstream fout(outfile);
	std::thread thds[opts.numthreads];
	int rstart=0;
	while (rstart<regions.size()) {
		// cout << "rstart: " << rstart << endl;
		vector< string > result(opts.numthreads);
		for (int i=0; i<opts.numthreads && rstart<regions.size(); ++i) {
			thds[i]=std::thread(vmrworker
					, std::ref(regions)
					, std::ref(chr)
					, rstart
					, std::ref(result[i])
					);
			rstart+=BATCH;
		}
		for (int i=0; i<opts.numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
		for (string& sout: result) {
			fout << sout;
		}
	}
	cout << "Finish " << chr << endl;
	return 0;
}

int mergechroutfiles(vector< string >& outfiles, string& outfile) {
	ofstream mergedLaneFile;
	mergedLaneFile.open(outfile.c_str(), ios_base::out);
	mergedLaneFile << "#chrom\tstart\tend\tnumsample\tnumcpg\tcpgs\tnominal\tsd\tNME\tstatistic" << endl;
	mergedLaneFile.close();

	string sysCmd;
	sysCmd = "cat " + strjoin(outfiles, " ") + " >> " + outfile;
	system(sysCmd.c_str());
	sysCmd = "rm -f " + strjoin(outfiles, " ");
	system(sysCmd.c_str());
	return 0;
}

int subtyping()
{
	vector< string > chroutfiles;
	for (string& chr : opts.chroms) {
		string chroutfile=opts.outfile+"_"+chr+".txt";
		if (! boost::filesystem::exists(chroutfile)) {
			vmrbychr(opts.methfiles[0], chr, chroutfile);
		}
		chroutfiles.push_back(chroutfile);
	}
	mergechroutfiles(chroutfiles, opts.outfile);
	return 0;
}

int cmeths2cpgs(vector< map< int, double > >& cmeths, string& chr, vector< VMC >& cpgs) {
	map<int, vector< double > > cpgratios;
	for (int si=0; si<cmeths.size(); ++si) {
		map< int, double >& sample=cmeths[si];
		for (auto it=sample.begin(); sample.end()!=it; ++it) {
			auto hit=cpgratios.find(it->first);
			if (cpgratios.end()!=hit) {
				hit->second[si]=it->second;
			} else {
				vector< double > ratios(cmeths.size(), -1); // -1: missing data
				ratios[si]=it->second;
				cpgratios[it->first]=ratios;
			}
		}
	}
	for (auto it=cpgratios.begin(); cpgratios.end()!=it; ++it) {
		VMC vmc;
		vmc.chrom=chr;
		vmc.start=it->first;
		vmc.end=vmc.start+2;
		vmc.ratios.assign(it->second.begin(), it->second.end());
		vmc.N=vmc.ratios.size();
		cpgs.push_back(vmc);
	}
	return 0;
}

int methfiles2cpgs(vector< string >& methfiles, string& chr, vector< VMC >& cpgs)
{
	vector< map< int, double > > cmeths; // replicate->pos->ratio
	methfiles2cmeththread(methfiles, chr, cmeths, opts.numthreads);
	cmeths2cpgs(cmeths, chr, cpgs);
	return 0;
}

double cpgNME(vector< double >& ratios) {
	int N=ratios.size();
	map< char, int > freqs;
	for (double r: ratios) {
		freqs[discretize(0, 1, opts.K, r)]++;
	}
	vector< double > probs;
	for (auto& freq: freqs) {
		probs.push_back(freq.second*1.0/N);
	}
	double nme=0;
	for (double p: probs) {
		if (p>0) {
			nme+=(-1.0)*p*log2(p);
		}
	}
	nme*=1.0/log2(1.0*opts.K);
	return nme;
}

int cpgmeansdnwe(vector< double >& ratios, double& nominal, double& sd, double& NME, int& N) {
	nominal=-1;
	sd=-1;
	NME=-1;
	if (ratios.empty()) return 0;
	vector< double > repratio;
	for(double ratio: ratios) {
		if (ratio>-1) {
			repratio.push_back(ratio);
		}
	}
	N=repratio.size();
	if (!repratio.empty()) {
		nominal=vec2mean(repratio);
		sd=vec2sd(repratio);
		NME=cpgNME(repratio);
	}
	return 0;
}


int vmcstats(VMC & vmc) {
	cpgmeansdnwe(vmc.ratios, vmc.nominal, vmc.sd, vmc.NME, vmc.N);
	return 0;
}

void vmcworker(vector< VMC >& cpgs, int rstart, string& output) {
	ostringstream sout;
	for (int r=0; r<BATCH && rstart<cpgs.size(); ++r, ++rstart) {
		VMC& cpg=cpgs[rstart];
		vmcstats(cpg);
		if (cpg.N>=opts.minsample) {
			sout << cpg.chrom << '\t'
				<< cpg.start << '\t'
				<< cpg.end << '\t'
				<< cpg.N << '\t'
				<< cpg.nominal << '\t'
				<< cpg.sd << '\t'
				<< cpg.NME
				// << '\t'
				// << strjoin(cpg.ratios)
				<< endl;
		}
	}
	output=sout.str();
}

int vmcbychr(vector< string >& methfiles, string& chr, string& vmcfile) {
	cout << "Start processing " << chr << endl;
	vector< VMC > cpgs;
	methfiles2cpgs(methfiles, chr, cpgs);

	ofstream fout(vmcfile);
	std::thread thds[opts.numthreads];
	int rstart=0;
	while (rstart<cpgs.size()) {
		vector< string > result(opts.numthreads);
		for (int i=0; i<opts.numthreads && rstart<cpgs.size(); ++i, rstart+=BATCH) {
			thds[i]=std::thread(vmcworker
					, std::ref(cpgs)
					, rstart
					, std::ref(result[i])
					);
		}
		for (int i=0; i<opts.numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
		for (string& sout: result) {
			fout << sout;
		}
	}
	cout << "Finish " << chr << endl;
	return 0;
}

int mergechrvmcfiles(vector< string >& vmcfiles, string& vmcfile)
{
	ofstream mergedVMCFile;
	mergedVMCFile.open(vmcfile.c_str(), ios_base::out);
	// mergedVMCFile << "#chrom\tstart\tend\tnumsample\tnominal\tsd\tNME\tratios" << endl;
	mergedVMCFile << "#chrom\tstart\tend\tnumsample\tnominal\tsd\tNME" << endl;
	mergedVMCFile.close();

	string sysCmd;
	sysCmd = "cat " + strjoin(vmcfiles, " ") + " >> " + vmcfile;
	system(sysCmd.c_str());
	sysCmd = "rm -f " + strjoin(vmcfiles, " ");
	system(sysCmd.c_str());
	return 0;
}

int vmcfile2map(string& vmcfile, map< string, map< int, VMC > >& vmcs) {
	ifstream fin(vmcfile);
	string line;
	while ((fin.good() && !fin.eof()) && getline(fin, line)) {
		if (line.empty() || line[0]=='#') continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of("\t"));
		VMC vmc;
		vmc.chrom=fields[0];
		vmc.start=stoi(fields[1]);
		vmc.end=stoi(fields[2]);
		vmc.N=stoi(fields[3]);
		vmc.nominal=stold(fields[4]);
		vmc.sd=stold(fields[5]);
		vmc.NME=stold(fields[6]);
		if (vmc.N>=opts.minsample && vmc.sd>=opts.sd && vmc.NME<=opts.NME) { // VMC
			vmcs[vmc.chrom][vmc.start]=vmc;
		}
	}
	fin.close();
	return 0;
}

int vmc2vmr(string& vmcfile, string& vmrfile)
{
	map< string, map< int, VMC > > vmcs; // chrom->start->VMC
	vmcfile2map(vmcfile, vmcs);

	ofstream fout(vmrfile);
	fout << "#chrom\tstart\tend\tnumcpgs\tnominal\tsd\tNME" << endl;
	for (auto chrit=vmcs.begin(); vmcs.end()!=chrit; ++chrit) {
		string chrom=chrit->first;
		auto vmcit=chrit->second.begin();
		while (chrit->second.end()!=vmcit) {
			VMR vmr;
			vmr.chrom=chrom;
			vmr.start=vmcit->first;
			vmr.end=vmcit->second.end;
			vmr.cpgs.push_back(vmcit->second);
			++vmcit;
			while (chrit->second.end()!=vmcit && vmcit->second.start<vmr.end+opts.maxdistvmcs) {
				vmr.end=vmcit->second.end;
				vmr.cpgs.push_back(vmcit->second);
				++vmcit;
			}
			if (vmr.cpgs.size()>=opts.mincpg) {
				vmr.N=vmr.cpgs.size();
				vmr.cpgs2nominal();
				vmr.cpgs2sd();
				vmr.cpgs2nme();
				fout << vmr.chrom << '\t'
					<< vmr.start << '\t'
					<< vmr.end << '\t'
					<< vmr.N << '\t'
					<< vmr.nominal << '\t'
					<< vmr.sd << '\t'
					<< vmr.NME << endl;
			}
		}
	}
	fout.close();
	return 0;
}

int vmcfile2mapwindow(string& vmcfile, map< string, map< int, VMC > >& vmcs) {
	ifstream fin(vmcfile);
	string line;
	while ((fin.good() && !fin.eof()) && getline(fin, line)) {
		if (line.empty() || line[0]=='#') continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of("\t"));
		VMC vmc;
		vmc.chrom=fields[0];
		vmc.start=stoi(fields[1]);
		vmc.end=stoi(fields[2]);
		vmc.N=stoi(fields[3]);
		vmc.nominal=stold(fields[4]);
		vmc.sd=stold(fields[5]);
		vmc.NME=stold(fields[6]);
		if (vmc.N>opts.minsample) {
			vmcs[vmc.chrom][vmc.start]=vmc;
		}
	}
	fin.close();
	return 0;
}
int vmc2vmrwindow(string& vmcfile, string& vmrfile)
{
	map< string, map< int, VMC > > vmcs; // chrom->start->VMC
	vmcfile2mapwindow(vmcfile, vmcs);

	ofstream fout(vmrfile);
	fout << "#chrom\tstart\tend\tnumcpgs\tnominal\tsd\tNME" << endl;
	for (auto chrit=vmcs.begin(); vmcs.end()!=chrit; ++chrit) {
		string chrom=chrit->first;
		auto vmcit=chrit->second.begin();
		while (chrit->second.end()!=vmcit) {
			VMR vmr;
			vmr.chrom=chrom;
			vmr.start=vmcit->first;
			vmr.end=vmcit->second.end;
			vmr.cpgs.push_back(vmcit->second);
			++vmcit;
			while (chrit->second.end()!=vmcit && vmcit->second.start<=vmr.start+opts.window) {
				vmr.end=vmcit->second.end;
				vmr.cpgs.push_back(vmcit->second);
				++vmcit;
			}
			if (vmr.cpgs.size()>=opts.mincpg) {
				vmr.N=vmr.cpgs.size();
				vmr.cpgs2nominal();
				vmr.cpgs2sd();
				vmr.cpgs2nme();
				fout << vmr.chrom << '\t'
					<< vmr.start << '\t'
					<< vmr.end << '\t'
					<< vmr.N << '\t'
					<< vmr.nominal << '\t'
					<< vmr.sd << '\t'
					<< vmr.NME << endl;
			}
		}
	}
	fout.close();
	return 0;
}

int subtypingvmcvmr()
{
	if (opts.vmcfile.empty()) {
		string obname=boost::filesystem::path(opts.outfile).replace_extension().string();
		opts.vmcfile=obname+".vmc.txt";
	}
	if (!boost::filesystem::exists(opts.vmcfile)) {
		boost::filesystem::create_directories(boost::filesystem::absolute(opts.vmcfile).parent_path());
		vector< string > chrvmcfiles;
		for (string& chr : opts.chroms) {
			string chrvmcfile=opts.vmcfile+"_"+chr+".vmc.txt";
			if (!boost::filesystem::exists(chrvmcfile)) {
				vmcbychr(opts.methfiles[0], chr, chrvmcfile);
			}
			chrvmcfiles.push_back(chrvmcfile);
		}
		mergechrvmcfiles(chrvmcfiles, opts.vmcfile);
	}
	boost::filesystem::create_directories(boost::filesystem::absolute(opts.outfile).parent_path());
	vmc2vmr(opts.vmcfile, opts.outfile);
	if (!opts.windowfile.empty()) {
		boost::filesystem::create_directories(boost::filesystem::absolute(opts.windowfile).parent_path());
		vmc2vmrwindow(opts.vmcfile, opts.windowfile);
	}
	return 0;
}

int main(int argc, const char ** argv)
{
	parse_options(argc, argv);
	if (opts.methfiles.size()==1) {
		if (opts.vmrmethod==1) {
			subtyping();
		} else if (opts.vmrmethod==0) {
			subtypingvmcvmr();
		}
	} else if (opts.methfiles.size()>1) {
		cerr << "Multiple groups are not implemented for VMC and VMR. Please specify replicates in one group." << endl;
	}
	return 0;
}
