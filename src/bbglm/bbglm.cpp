#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <boost/algorithm/string.hpp>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <cstdlib>
#include <thread>

#include <stan/services/error_codes.hpp>
#include <cmdstan/command.hpp>
#include <stan/math.hpp>
#include <boost/exception/diagnostic_information.hpp>
#include <boost/exception_ptr.hpp>
#include "bbglm.hpp"

#include <cstdio>
#include <cstring>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <errno.h>

#include "types.h"

using namespace boost::program_options;
using namespace std;

class Opts {
	public:
		vector< vector< string > > methfiles;
		vector< string > chromstr;
		vector< string > chroms;
		map< string, int > chromsizes;
		int length;
		int Jx;
		int Kx;
		int mindepth;
		// int numthreads;
		int readthreads;
		int batchthreads;
		string outfile;
		double qvaluethr;
		double nominaldiff;
		int maxdistdmcs;
		int mindmc;
	public:
		Opts(): Jx(0), Kx(0), mindepth(1), readthreads(10), batchthreads(5), length(20000000), qvaluethr(0.05), nominaldiff(0.2), maxdistdmcs(300), mindmc(3) {}
	public:
		void out() {
			cout << "Methylation files:" << endl;
			for (int i=0; i<methfiles.size(); i++) {
				cout << "group" << i+1 << ": " << strjoin(methfiles[i]) << endl;
			}
			cout << "Number of samples: " << Jx << endl;
			cout << "Number of groups: " << Kx << endl;
			cout << "Chromosomes: " << strjoin(chromstr) << endl;
			cout << "Length to split a chromosome: " << length << endl;
			cout << "Minimum depth: " << mindepth << endl;
			cout << "Number of read threads: " << readthreads << endl;
			cout << "Number of batch threads: " << batchthreads << endl;
			cout << "Qvalue threshold for DMC: " << qvaluethr << endl;
			cout << "Nominal methylation difference threshold for DMC: " << nominaldiff << endl;
			cout << "Max distance between DMCs for DMR: " << maxdistdmcs << endl;
			cout << "Min number of DMCs in a DMR: " << mindmc << endl;
			cout << "outfile: " << outfile << endl;
		}
} opts;

int parse_options(int ac, const char ** av) {
	try
	{
		options_description desc{"Allowed options"};
		desc.add_options()
			("help,h", "Produce help message.")
			("methfile,m", value< vector< string > >()->multitoken(), "Methylation BED files. The BED file is generated by `MCALL` in MOABS. Replicates in a group are concatenated by comma `,`. Multiple groups can be specified. For example, `-m g1_r1.bed,g1_r2.bed -m g2_r1.bed -m g3_r1.bed,g3_r2.bed,g3_r3.bed`.")
			("chrom,c", value< vector< string > >()->multitoken(), "A specific chromosome for analysis. Can be specified multiple times for multiple chromosomes. The size can be encoded for a chromosome. For example, `-c chr1:248956422 -c chr2:242193529`. The size can be used to split a chromosome for running in small batches. Default: all chromosomes appear in methylation files.")
			("length,l", value<int>()->default_value(20000000), "Split length of coordinates in a chromomsome. This is necessary for many replicates with a limited memory. To enable small-batch running, size info should be specificed by `-c|--chrom`. Because the size of chr1 in hg38 is >200 million, 1/10th (20M) can be good to go. Default: 20000000.")
			("mindepth,d", value<int>()->default_value(1), "Minimum depth for a CpG coverage. Default: 1.")
			("readthreads,t", value<int>()->default_value(10), "Number of read threads. Default: 10.")
			("batchthreads,b", value<int>()->default_value(5), "Number of batch threads. Default: 5.")
			("qval", value<double>()->default_value(0.05, "0.05"), "Q-value threshold for DMC. Default: 0.05.")
			("nominaldiff", value<double>()->default_value(0.2, "0.2"), "Nominal methylation difference threshold for DMC. Default: 0.2.")
			("maxdistdmcs", value<int>()->default_value(300), "Maximum distance between consecutive DMCs for DMR. Default: 300.")
			("mindmc", value<int>()->default_value(3), "Minimum number ofDMCs in a DMR. Default: 3.")
			("outfile,o", value<string>()->default_value(""), "Output file.")
			;

		variables_map vm;
		store(parse_command_line(ac, av, desc), vm);
		notify(vm);

		if (vm.count("help")) {
			cout << desc << endl;
			cout << "Examples: " <<endl;
			cout << "  " << av[0] << " -m g1_r1.bed,g1_r2.bed -m g2_r1.bed -m g3_r1.bed,g3_r2.bed,g3_r3.bed -o output.txt" << endl;
			cout << endl;
			cout << "Date: 2020/08/19" << endl;
			cout << "Authors: Jin Li <lijin.abc@gmail.com>" << endl;
			exit(0);
		}

		for(map<string, variable_value>::iterator it=vm.begin(); it!=vm.end(); ++it) {
			string k=it->first;
			if( k == "methfile"){
				vector< string > files=vm[k].as< vector< string > >();
				int numsample=0;
				int numgroup=0;
				for (string &fstr: files) {
					vector< string > gfiles;
					boost::split(gfiles, fstr, boost::is_any_of(","));
					opts.methfiles.push_back(gfiles);
					numsample+=gfiles.size();
					numgroup++;
				}
				opts.Jx=numsample;
				opts.Kx=numgroup;
			} else if( k == "chrom"){
				vector< string > vchrs=vm[k].as< vector< string > >();
				set< string > uniqchrs;
				for (string& chr: vchrs) {
					uniqchrs.insert(chr);
				}
				opts.chromstr.assign(uniqchrs.begin(), uniqchrs.end());

				for (string& chr: opts.chromstr) {
					vector< string > fields;
					boost::split(fields, chr, boost::is_any_of(":"));
					opts.chroms.push_back(fields[0]);
					if (fields.size()==2) {
						opts.chromsizes[fields[0]]=stoi(fields[1]);
					}
				}
			} else if( k == "length"){
				opts.length=vm[k].as<int>();
			} else if( k == "mindepth"){
				opts.mindepth=vm[k].as<int>();
			} else if( k == "readthreads"){
				opts.readthreads=vm[k].as<int>();
			} else if( k == "batchthreads"){
				opts.batchthreads=vm[k].as<int>();
			} else if( k == "qval"){
				opts.qvaluethr=vm[k].as<double>();
			} else if( k == "nominaldiff"){
				opts.nominaldiff=vm[k].as<double>();
			} else if( k == "maxdistdmcs"){
				opts.maxdistdmcs=vm[k].as<int>();
			} else if( k == "mindmc"){
				opts.mindmc=vm[k].as<int>();
			} else if( k == "outfile"){
				opts.outfile=vm[k].as<string>();
			} else {
				cerr << "Error: invalid option " << k << endl;
				exit(1);
			}
		}
		if (opts.methfiles.empty()) {
			cerr << "Error: -m|--methfile must be specified." << endl;
			cout << desc << endl;
			exit(1);
		}
		if (opts.outfile.empty()) {
			cerr << "Error: -o|--outfile must be specified." << endl;
			cout << desc << endl;
			exit(1);
		}
		if (opts.chroms.empty()) {
			getchrs(opts.methfiles, opts.chroms);
			opts.chromstr.assign(opts.chroms.begin(), opts.chroms.end());
		}
		opts.out();
	} catch (const error &ex) {
		cerr << ex.what() << endl;
	}
	return 0;
}

int methfile2cmeth(string& methfile, string& chr, map< string, map< int, cMeth > >& methBs)
{
	if (!boost::filesystem::exists(methfile)) {
		cerr << "Error: input file missing " << methfile << endl;
		exit(1);
	}
	cout << "start reading file " << methfile << " " << chr << endl;
	readLaneToStrandSpecificHash(methfile, methBs, chr, opts.mindepth);

	// // debug
	// cout << methfile << endl;
	// for (auto& p: methBs[chr]) {
	// 	cout << p.first << ' ' << p.second.totalC << ' ' << p.second.methC << endl;
	// }

	cout << "finish reading file " << methfile << " " << chr << endl;
	return 0;
}

// [lower, upper)
int methfile2cmethrange(string& methfile, string& chr, int lower, int upper, map< string, map< int, cMeth > >& methBs)
{
	if (!boost::filesystem::exists(methfile)) {
		cerr << "Error: input file missing " << methfile << endl;
		exit(1);
	}
	cout << "start reading file " << methfile << " " << chr << " [" << lower << "," << upper << ")" << endl;
	readLaneToStrandSpecificHash(methfile, methBs, chr, lower, upper, opts.mindepth);

	// // debug
	// cout << methfile << endl;
	// for (auto& p: methBs[chr]) {
	// 	cout << p.first << ' ' << p.second.totalC << ' ' << p.second.methC << endl;
	// }

	cout << "finish reading file " << methfile << " " << chr << " [" << lower << "," << upper << ")" << endl;
	return 0;
}

int files2cmethg(
		vector< string >& methfiles
		, string& chr
		, vector< map< string, map< int, cMeth > > >& cmethg
		, int numthreads
		)
{
	cmethg.resize(methfiles.size());
	std::thread thds[numthreads];
	int methindex=0;
	while (methindex<methfiles.size()) {
		for (int i=0; i<numthreads && methindex<methfiles.size(); ++i, ++methindex) {
			thds[i]=std::thread(methfile2cmeth
					, std::ref(methfiles[methindex])
					, std::ref(chr)
					, std::ref(cmethg[methindex])
					);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
	}
	return 0;
}

int files2cmethg(
		vector< string >& methfiles
		, string& chr
		, int lower
		, int upper
		, vector< map< string, map< int, cMeth > > >& cmethg
		, int numthreads
		)
{
	cmethg.resize(methfiles.size());
	std::thread thds[numthreads];
	int methindex=0;
	while (methindex<methfiles.size()) {
		for (int i=0; i<numthreads && methindex<methfiles.size(); ++i, ++methindex) {
			thds[i]=std::thread(methfile2cmethrange
					, std::ref(methfiles[methindex])
					, std::ref(chr)
					, lower
					, upper
					, std::ref(cmethg[methindex])
					);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}
	}
	return 0;
}

int methfiles2cmeth(
		vector< vector< string > >& methfiles
		, string& chr
		, int lower
		, int upper
		, vector< vector< map< string, map< int, cMeth > > > >& cmeths
		, int numthreads
		)
{
	for (int g=0; g<methfiles.size(); g++) {
		vector< map< string, map< int, cMeth > > > cmethg;
		files2cmethg(methfiles[g], chr, lower, upper, cmethg, numthreads);
		cmeths.push_back(cmethg);
	}
	return 0;
}

int methfiles2cmeth(
		vector< vector< string > >& methfiles
		, string& chr
		, vector< vector< map< string, map< int, cMeth > > > >& cmeths
		, int numthreads
		)
{
	for (int g=0; g<methfiles.size(); g++) {
		vector< map< string, map< int, cMeth > > > cmethg;
		files2cmethg(methfiles[g], chr, cmethg, numthreads);
		cmeths.push_back(cmethg);
	}
	return 0;
}

int methfiles2cmeth(
		vector< vector< string > >& methfiles
		, string& chr
		, vector< vector< map< string, map< int, cMeth > > > >& cmeths
		)
{
	for (int g=0; g<methfiles.size(); g++) {
		vector< map< string, map< int, cMeth > > > cmethg; // replicate->cmeth
		for (int r=0; r<methfiles[g].size(); r++) {
			string methfile=methfiles[g][r];
			map< string, map< int, cMeth > > cmeth;
			methfile2cmeth(methfile, chr, cmeth);
			cmethg.push_back(cmeth);
		}
		cmeths.push_back(cmethg);
	}
	return 0;
}

int model_matrix(vector< int >& g, vector< int >& matrix)
{
	int Kx=g.size();
	int Jx=0;
	for (auto r:g) {
		Jx+=r;
	}
	matrix.resize(Jx*Kx, 0);
	int pos=0;
	for (int i=0; i<Jx; i++) {
		matrix[pos++]=1;
	}
	int cumsum=0;
	for (int j=1; j<Kx; j++) {
		cumsum+=g[j-1];
		pos=cumsum+j*Jx;
		for (int i=0; i<g[j]; i++) {
			matrix[pos++]=1;
		}
	}
	return 0;
}

int bbglmmle(int Jx, int Kx, vector< int >& design, vector< int >& tcs, vector< int >& mcs, vector< double >& fit)
{
	std::stringstream ss;
	ss << "Jx <- " << Jx << endl;
	ss << "Kx <- " << Kx << endl;
	ss << "X <- structure(c(" << strjoin(design) << "), .Dim=c(" << Jx << "," << Kx << "))" << endl;
	ss << "countx <- c(" << strjoin(mcs) << ")" << endl;
	ss << "totalx <- c(" << strjoin(tcs) << ")" << endl;
	std::istringstream ifs(ss.str());
	const char* arr[] = {"PROGRAM", "optimize", "data", "file=filename", "random", "seed=123"};
	std::stringstream ofs;
	int exitcode=cmdstan::command(6, arr, ifs, ofs);

	string line;
	while ((ofs.good() && !ofs.eof()) && getline(ofs, line)) {
		if (line.empty()) continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of(","));
		if (fields[0]=="lp__") continue;
		for (auto& field: fields) {
			fit.push_back(stold(field));
		}
		break;
	}
	return exitcode;
}

int bbglmmlelrt(int sJx, int sKx, vector< int >& groupsize, vector< int >& tcs, vector< int >&mcs, double& ssx, vector< double >& pi, double& pvalue) {
	vector< int > designfull;
	vector< double > fitfull;
	model_matrix(groupsize, designfull);
	bbglmmle(sJx, sKx, designfull, tcs, mcs, fitfull);
	ssx=fitfull[1];
	pi.resize(sKx, -1);
	for (int j=0; j<sKx; j++) {
		pi[j]=fitfull[j+sKx+2];
	}
	pvalue=-1;
	if (sKx>1) {
		vector< int > designnull(sJx, 1);
		vector< double > fitnull;
		bbglmmle(sJx, 1, designnull, tcs, mcs, fitnull);
		double deviance=fitfull[0]-fitnull[0];
		pvalue=1.0;
		if (deviance>0) {
			pvalue=1.0-stan::math::chi_square_cdf(2*deviance, sKx-1);
		}
	}
	return 0;
}

// shmid:
// -1: will not use IPC
// otherwise: use allocated shared memory
int bbglmmlelrtbatch(map< int, BBGLMLRT> & fits, int shmid) {
	if (-1==shmid) {
		// do not use IPC
		// i.e., no need to fork. This is necessary for many replicates with limited memory.
		for (auto it=fits.begin(); it!=fits.end(); ++it) {
			BBGLMLRT& sitefit=it->second;
			bbglmmlelrt(sitefit.sJx, sitefit.sKx, sitefit.groupsize, sitefit.tcs, sitefit.mcs, sitefit.ssx, sitefit.pi, sitefit.pvalue);
		}
		return 0;
	}

	pid_t cid=fork();
	if (cid==-1) {
		fprintf(stderr, "Fork error");
		exit(1);
	} else if (cid==0) {
		string result;
		for (auto it=fits.begin(); it!=fits.end(); ++it) {
			BBGLMLRT& sitefit=it->second;
			bbglmmlelrt(sitefit.sJx, sitefit.sKx, sitefit.groupsize, sitefit.tcs, sitefit.mcs, sitefit.ssx, sitefit.pi, sitefit.pvalue);
			result+=to_string(it->first)+"\t"+to_string(sitefit.ssx)+"\t"+strjoin(sitefit.pi)+"\t"+double2string(sitefit.pvalue, 24)+"\n";
			// cout << "child: " << result << endl;
		}

		char * pchd=(char *) shmat(shmid, 0, 0);
		if (pchd==(char *)-1) {
			perror("Error: child attach failure");
			exit(1);
		}
		pchd[0]='\0'; // reset shared memory
		strcpy(pchd, result.c_str());

		if (-1==shmdt(pchd)) {
			perror("Error: child detach failure");
			exit(1);
		}
		exit(0);
	} else {
		waitpid(cid, NULL, 0);
		char * pprt=(char *) shmat(shmid, 0, 0);
		if (pprt==(char *)-1) {
			perror("Error: parent attach failure");
			exit(1);
		}

		// cout << "parent: "  << shmid << ' ' << pprt;

		std::vector<string> lines;
		boost::split(lines, pprt, boost::is_any_of("\n"));

		// for (string& line: lines) {
		// 	cout << "after parse: " << line << endl;
		// }

		for (auto& line : lines) {
			if (line.empty()) continue;
			std::vector<string> fields;
			boost::split(fields, line, boost::is_any_of("\t"));
			if (fields.size()==4) {
				int start=stoi(fields[0]);
				fits[start].ssx=stold(fields[1]);
				std::vector<string> subfields;
				boost::split(subfields, fields[2], boost::is_any_of(","));
				for (int i=0; i<subfields.size(); ++i) {
					fits[start].pi.push_back(stold(subfields[i]));
				}
				fits[start].pvalue=stold(fields[3]);
			} else {
				cerr << "Pass: " << line << endl;
			}
		}
		pprt[0]='\0';
		if (-1==shmdt(pprt)) {
			perror("Error: parent detach failure");
			exit(1);
		}
	}
	return 0;
}

// shmid:
// -1: will not use IPC
// otherwise: use allocated shared memory
void bbglmworker(
		int shmid
		, vector< vector< map< string, map< int, cMeth > > > >& cmeths
		, string& chr
		, set< int > :: iterator it
		, set< int > :: iterator& pend
		, int pstart
		, string& output
		)
{
	advance(it, pstart);
	map< int, BBGLMLRT > fits;
	for (int i=0; i<BATCH && it!=pend; ++i, ++it) {
		int site=(*it);
		vector< int > groupid;
		vector< int > groupsize;
		vector< int > tcs;
		vector< int > mcs;
		int sJx=0;
		int sKx=0;
		for (int groupindex=0; groupindex<cmeths.size(); groupindex++) {
			vector< int > grouptc;
			vector< int > groupmc;
			for (int replicateindex=0; replicateindex<cmeths[groupindex].size(); replicateindex++) {
				auto it=cmeths[groupindex][replicateindex][chr].find(site);
				if (it!=cmeths[groupindex][replicateindex][chr].end()) {
					grouptc.push_back(it->second.totalC);
					groupmc.push_back(it->second.methC);
				}
			}
			if (!grouptc.empty()) {
				groupsize.push_back(grouptc.size());
				tcs.insert(tcs.end(), grouptc.begin(), grouptc.end());
				mcs.insert(mcs.end(), groupmc.begin(), groupmc.end());
				sKx++;
				sJx+=grouptc.size();
				groupid.push_back(groupindex+1); // map to original group
			}
		}
		if (sJx>0) {
			BBGLMLRT fit;
			fit.sJx=sJx;
			fit.sKx=sKx;
			fit.groupid=groupid;
			fit.groupsize=groupsize;
			fit.tcs=tcs;
			fit.mcs=mcs;
			fits[site]=fit;
		} else {
			cerr << "Error: should not happen at " << chr << " " << site << endl;
		}
	}

	bbglmmlelrtbatch(fits, shmid);

	ostringstream sout;
	for (auto& fit: fits) {
		int site=fit.first;
		BBGLMLRT& b=fit.second;
		vector< string > groupidstr(b.sKx, "g");
		for (int i=0; i<b.sKx; i++) {
			groupidstr[i]+=tostring(b.groupid[i]);
		}
		/*
			 sout << chr << '\t'
			 << site << '\t'
			 << site+1 << '\t'
			 << b.sKx << '\t'
			 << strjoin(groupidstr, b.groupsize, ":") << '\t'
			 << strjoin(b.tcs) << '\t'
			 << strjoin(b.mcs) << '\t'
			 << strjoin(b.pi) << '\t'
			 << b.ssx << '\t'
			 << b.pvalue << endl;
			 */

		// Do not show totalCs and methCs due to
		// 1. many replicates will overwhelm memory, and
		// 2. they are redundant compared to inputs
		sout << chr << '\t'
			<< site << '\t'
			<< site+1 << '\t'
			<< b.sKx << '\t'
			<< strjoin(groupidstr, b.groupsize, ":") << '\t'
			<< strjoin(b.pi) << '\t'
			<< b.ssx << '\t'
			<< b.pvalue << endl;
	}
	output=sout.str();
	fits.clear();
	//cout << output;
}

int cmeths2bbglm(
		vector< vector< map< string, map< int, cMeth > > > >& cmeths
		, string& chr
		, int numthreads
		, string& outfile
		)
{
	set< int > sites;
	for (auto& group: cmeths) {
		for (auto& replicate: group) {
			for (auto& cpg: replicate[chr]) {
				sites.insert(cpg.first);
			}
		}
	}

	ofstream fout(outfile);
	set< int >::iterator pbegin=sites.begin();
	set< int >::iterator pend=sites.end();
	int pstart=0;
	while (pstart<sites.size()) {
		if (1==numthreads) { // one batch thread will not use IPC
			for (int i=0; i<numthreads && pstart<sites.size(); ++i) {
				string result;
				int shmid=-1; // -1 for a special process
				bbglmworker(shmid, cmeths, chr, pbegin, pend, pstart, result);
				// cout << result;
				fout << result;
				pstart+=BATCH;
			}
			continue;
		}

		// cout << "debug: " << pstart << endl;

		vector< int > shmids;
		std::thread thds[numthreads];
		vector< string > result(numthreads);
		for (int i=0; i<numthreads && pstart<sites.size(); ++i) {
			int shmid=shmget(IPC_PRIVATE, BATCH*UNITSIZE, 0600|IPC_CREAT);
			if (shmid==-1) {
				perror("Error: shared memory allocation failure");
				exit(1);
			}
			thds[i]=std::thread(bbglmworker
					, shmid
					, std::ref(cmeths)
					, std::ref(chr)
					, std::ref(pbegin)
					, std::ref(pend)
					, pstart
					, std::ref(result[i])
					);
			pstart+=BATCH;
			shmids.push_back(shmid);
		}
		for (int i=0; i<numthreads; i++) {
			if (thds[i].joinable()) {
				thds[i].join();
			}
		}

		/* A bug on Mac
		 * corrupted results by ofstream
		 */
		for (string& sout: result) {
			// cout << sout;
			fout << sout;
		}
		for (int shmid: shmids) {
			if (-1==shmctl(shmid, IPC_RMID, 0)) {
				perror("Error: shared memory remove failure");
				exit(1);
			}
		}
	}

	return 0;
}

int bbglmbychrsplit(vector< vector< string > >& methfiles, string& chr, int lower, int upper, string& outfile)
{
	cout << "Start processing " << chr << " [" << lower << "," << upper << ")" << endl;
	vector< vector< map< string, map< int, cMeth > > > > cmeths; // group->replicate->chr->pos->[totalC,methC,strand,nextN]
	methfiles2cmeth(methfiles, chr, lower, upper, cmeths, opts.readthreads);
	cmeths2bbglm(cmeths, chr, opts.batchthreads, outfile);
	cout << "Finish " << chr << " [" << lower << "," << upper << ")" << endl;
	return 0;
}

int mergesplitfile(vector< string >& outfiles, string& outfile)
{
	string sysCmd;
	sysCmd = "cat " + strjoin(outfiles, " ") + " > " + outfile;
	system(sysCmd.c_str());
	sysCmd = "rm -f " + strjoin(outfiles, " ");
	system(sysCmd.c_str());
	return 0;
}

int bbglmbychr(vector< vector< string > >& methfiles, string& chr, int chromsize, int length, string& outfile)
{
	cout << "Start processing " << chr << endl;
	vector< string > splitfiles;
	for (int lower=1; lower<=chromsize; lower+=length) {
		int upper=lower+length;
		string splitfile=outfile+"_"+tostring(lower)+"_"+tostring(upper)+".txt";
		bbglmbychrsplit(methfiles, chr, lower, upper, splitfile); // [lower, upper)
		splitfiles.push_back(splitfile);
	}
	mergesplitfile(splitfiles, outfile);
	cout << "Finish " << chr << endl;
	return 0;
}

int bbglmbychr(vector< vector< string > >& methfiles, string& chr, string& outfile)
{
	cout << "Start processing " << chr << endl;
	vector< vector< map< string, map< int, cMeth > > > > cmeths; // group->replicate->chr->pos->[totalC,methC,strand,nextN]
	methfiles2cmeth(methfiles, chr, cmeths, opts.readthreads);
	cmeths2bbglm(cmeths, chr, opts.batchthreads, outfile);

	// /*
	//  * Refactor to cmeths2bbglm()
	//  */
	// set< int > sites;
	// for (auto& group: cmeths) {
	// 	for (auto& replicate: group) {
	// 		for (auto& cpg: replicate[chr]) {
	// 			sites.insert(cpg.first);
	// 		}
	// 	}
	// }

	// ofstream fout(outfile);
	// set< int >::iterator pbegin=sites.begin();
	// set< int >::iterator pend=sites.end();
	// int pstart=0;
	// while (pstart<sites.size()) {
	// 	if (1==opts.batchthreads) { // one batch thread will not use IPC
	// 		for (int i=0; i<opts.batchthreads && pstart<sites.size(); ++i) {
	// 			string result;
	// 			int shmid=-1; // -1 for a special process
	// 			bbglmworker(shmid, cmeths, chr, pbegin, pend, pstart, result);
	// 			// cout << result;
	// 			fout << result;
	// 			pstart+=BATCH;
	// 		}
	// 		continue;
	// 	}

	// 	// cout << "debug: " << pstart << endl;

	// 	vector< int > shmids;
	// 	std::thread thds[opts.batchthreads];
	// 	vector< string > result(opts.batchthreads);
	// 	for (int i=0; i<opts.batchthreads && pstart<sites.size(); ++i) {
	// 		int shmid=shmget(IPC_PRIVATE, BATCH*UNITSIZE, 0600|IPC_CREAT);
	// 		if (shmid==-1) {
	// 			perror("Error: shared memory allocation failure");
	// 			exit(1);
	// 		}
	// 		thds[i]=std::thread(bbglmworker
	// 				, shmid
	// 				, std::ref(cmeths)
	// 				, std::ref(chr)
	// 				, std::ref(pbegin)
	// 				, std::ref(pend)
	// 				, pstart
	// 				, std::ref(result[i])
	// 				);
	// 		pstart+=BATCH;
	// 		shmids.push_back(shmid);
	// 	}
	// 	for (int i=0; i<opts.batchthreads; i++) {
	// 		if (thds[i].joinable()) {
	// 			thds[i].join();
	// 		}
	// 	}

	// 	/* A bug on Mac
	// 	 * corrupted results by ofstream
	// 	 */
	// 	for (string& sout: result) {
	// 		// cout << sout;
	// 		fout << sout;
	// 	}
	// 	for (int shmid: shmids) {
	// 		if (-1==shmctl(shmid, IPC_RMID, 0)) {
	// 			perror("Error: shared memory remove failure");
	// 			exit(1);
	// 		}
	// 	}
	// }
	cout << "Finish " << chr << endl;
	return 0;
}

int mergechroutfiles(vector< string >& outfiles, string& outfile) {
	ofstream mergedLaneFile;
	mergedLaneFile.open(outfile.c_str(), ios_base::out);
	// mergedLaneFile << "#chrom\tstart\tend\tnumgroup\tgroupsize\ttotalCs\tmethCs\tgroupratio\tssx\tpvalue" << endl;
	mergedLaneFile << "#chrom\tstart\tend\tnumgroup\tgroupsize\tgroupratio\tssx\tpvalue" << endl;
	mergedLaneFile.close();

	string sysCmd;
	sysCmd = "cat " + strjoin(outfiles, " ") + " >> " + outfile;
	system(sysCmd.c_str());
	sysCmd = "rm -f " + strjoin(outfiles, " ");
	system(sysCmd.c_str());
	return 0;
}

double vec2mean(vector< double >& vec) {
	double sum=0.0;
	for (double v: vec) {
		sum+=v;
	}
	return sum/vec.size();
}

int bbglmlrt2dmcdmr(
		string& infile
		, string& dmcfile
		, string& dmrfile
		, double qvaluethr
		, double nominaldiff
		, int maxdistdmcs
		, int mindmc
		, map< string, map< int, double > >& qvalues
		)
{
	map< string, map< int, DMC > > dmcs; // chr->start->DMC
	ofstream dmcout(dmcfile);
	dmcout << "#chrom\tstart\tend\tnominal_1\tnominal_2\tdiff_1-2\tssx\tpvalue\tqvalue\tclass" << endl;
	ifstream fin(infile);
	string line;
	while ((fin.good() && !fin.eof()) && getline(fin, line)) {
		if (line.empty() || line[0]=='#') continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of("\t"));

		int numgroup=stoi(fields[3]);
		if (numgroup<opts.Kx) continue; // One group only

		string chrom=fields[0];
		int start=stoi(fields[1]);
		vector< string > groupratios;
		boost::split(groupratios, fields[5], boost::is_any_of(","));
		double nominal1=stold(groupratios[0]);
		double nominal2=stold(groupratios[1]);
		double methdiff=nominal1-nominal2;
		double qvalue=qvalues[chrom][start];

		string label="ns";
		// default double precision is 6
		if (
				((fabs(qvalue-qvaluethr)<1e-6) || (qvalue<qvaluethr)) &&
				((fabs(fabs(methdiff)-nominaldiff)<1e-6) || (fabs(methdiff)>nominaldiff))
			 )
		{ // significant
			if (methdiff<0) {
				label="hypo";
			} else {
				label="hyper";
			}
		}

		// a bug here with very small difference: e.g., (0.2 - 1e-7)<0.2, it could be a hyper under a low resolution (1e-6)
		// if (qvalue>qvaluethr || fabs(methdiff)<nominaldiff) {
		// 	label="ns";
		// } else { // significant
		// 	if (methdiff<0) {
		// 		label="hypo";
		// 	} else {
		// 		label="hyper";
		// 	}
		// }

		DMC dmc;
		dmc.chrom=fields[0];
		dmc.start=stoi(fields[1]);
		dmc.end=stoi(fields[2]);
		dmc.ssx=stold(fields[6]);
		dmc.nominal1=nominal1;
		dmc.nominal2=nominal2;
		dmc.pvalue=stold(fields[7]);
		dmc.qvalue=qvalue;
		dmc.label=label;

		dmcs[dmc.chrom][dmc.start]=dmc;

		dmcout << dmc.chrom << '\t'
			<< dmc.start << '\t'
			<< dmc.end << '\t'
			<< dmc.nominal1 << '\t'
			<< dmc.nominal2 << '\t'
			<< methdiff << '\t'
			<< dmc.ssx << '\t'
			<< dmc.pvalue << '\t'
			<< dmc.qvalue << '\t'
			<< dmc.label << endl;
	}
	fin.close();
	dmcout.close();

	ofstream dmrout(dmrfile);
	dmrout << "#chrom\tstart\tend\t#dmc\tnominal_1\tnominal_2\tdiff_1-2\tclass" << endl;
	for (auto chrit=dmcs.begin(); chrit!=dmcs.end(); ++chrit) {
		map< int, DMC >& dmcchr=chrit->second;
		DMR dmr;
		for (auto dmcit=dmcchr.begin(); dmcchr.end()!=dmcit; ++dmcit) {
			DMC& dmc=dmcit->second;
			if (dmc.label=="ns") continue; // skip the non-significant CpGs

			if (dmr.start==-1) { // the first DMC
				dmr.chrom=dmc.chrom;
				dmr.start=dmc.start;
				dmr.end=dmc.end;
				dmr.nominal1.push_back(dmc.nominal1);
				dmr.nominal2.push_back(dmc.nominal2);
				dmr.label=dmc.label;
			} else { // trying to extend a DMR
				if (dmc.label!=dmr.label || dmc.start-dmr.end>maxdistdmcs) { // can not extend
					if (dmr.nominal1.size()>=mindmc) { // save a DMR
						double mean1=vec2mean(dmr.nominal1);
						double mean2=vec2mean(dmr.nominal2);
						dmrout << dmr.chrom << '\t'
							<< dmr.start << '\t'
							<< dmr.end << '\t'
							<< dmr.nominal1.size() << '\t'
							<< mean1 << '\t'
							<< mean2 << '\t'
							<< mean1-mean2 << '\t'
							<< dmr.label << endl;
					}
					dmr.clear();
					dmr.chrom=dmc.chrom; // start a new DMR from this DMC
					dmr.start=dmc.start;
					dmr.end=dmc.end;
					dmr.nominal1.push_back(dmc.nominal1);
					dmr.nominal2.push_back(dmc.nominal2);
					dmr.label=dmc.label;
				} else { // extending a DMR
					dmr.end=dmc.end;
					dmr.nominal1.push_back(dmc.nominal1);
					dmr.nominal2.push_back(dmc.nominal2);
				}
			}
		}
		if (dmr.nominal1.size()>=mindmc) { // try to save the last DMR
			double mean1=vec2mean(dmr.nominal1);
			double mean2=vec2mean(dmr.nominal2);
			dmrout << dmr.chrom << '\t'
				<< dmr.start << '\t'
				<< dmr.end << '\t'
				<< dmr.nominal1.size() << '\t'
				<< mean1 << '\t'
				<< mean2 << '\t'
				<< mean1-mean2 << '\t'
				<< dmr.label << endl;
		}
	}
	dmrout.close();
	return 0;
}

int lrt2qvalues(string& infile, map< string, map< int, double > >& qvalues)
{
	map< string, map< int, int > > pvalue2index;
	vector< double > p;
	ifstream fin(infile);
	string line;
	while ((fin.good() && !fin.eof()) && getline(fin, line)) {
		if (line.empty() || line[0]=='#') continue;
		vector< string > fields;
		boost::split(fields, line, boost::is_any_of("\t"));

		int numgroup=stoi(fields[3]);
		if (numgroup<opts.Kx) continue; // One group only
		string chrom=fields[0];
		int start=stoi(fields[1]);
		double pvalue=stold(fields[7]);
		p.push_back(pvalue);
		pvalue2index[chrom][start]=p.size()-1;
	}
	vector< double > q;
	padjustfdr(p, q);
	// // debug
	// for (auto pchr: pvalue2index) {
	// 	for (auto pstart: pchr.second) {
	// 		cout << pchr.first << '\t' << pstart.first << '\t' << p[pstart.second] << '\t' << q[pstart.second] << endl;
	// 	}
	// }

	for (auto pchr: pvalue2index) {
		for (auto pstart: pchr.second) {
			qvalues[pchr.first][pstart.first]=q[pstart.second];
		}
	}
	return 0;
}

int main(int argc, const char ** argv)
{
	parse_options(argc, argv);
	boost::filesystem::create_directories(boost::filesystem::absolute(opts.outfile).parent_path());
	if (!boost::filesystem::exists(opts.outfile)) {
		vector< string > chroutfiles;
		for (string& chr : opts.chroms) {
			string chroutfile=opts.outfile+"_"+chr+".txt";
			if (!boost::filesystem::exists(chroutfile)) {
				if (opts.chromsizes.end()!=opts.chromsizes.find(chr)) {
					bbglmbychr(opts.methfiles, chr, opts.chromsizes[chr], opts.length, chroutfile);
				} else {
					bbglmbychr(opts.methfiles, chr, chroutfile);
				}
			}
			chroutfiles.push_back(chroutfile);
		}
		mergechroutfiles(chroutfiles, opts.outfile);
	}
	if (opts.Kx==2) { // two groups for DMCs and DMRs
		map< string, map< int, double > > qvalues;
		lrt2qvalues(opts.outfile, qvalues);
		string obname=boost::filesystem::path(opts.outfile).replace_extension().string();
		string dmcfile=obname+".dmc.txt";
		string dmrfile=obname+".dmr.txt";
		bbglmlrt2dmcdmr(opts.outfile, dmcfile, dmrfile, opts.qvaluethr, opts.nominaldiff, opts.maxdistdmcs, opts.mindmc, qvalues);
	}
	return 0;
}
